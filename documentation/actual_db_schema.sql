-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://github.com/pgadmin-org/pgadmin4/issues/new/choose if you find any bugs, including reproduction steps.
BEGIN;


CREATE TABLE IF NOT EXISTS public.activities
(
    activity_id serial NOT NULL,
    team_id integer,
    location_id integer,
    title character varying(255) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default" NOT NULL,
    min_participants integer DEFAULT 1,
    max_participants integer NOT NULL,
    price numeric(10, 2) NOT NULL,
    difficulty_level character varying(50) COLLATE pg_catalog."default",
    created_by integer,
    leader_id integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    activity_status character varying(20) COLLATE pg_catalog."default" DEFAULT 'active'::character varying,
    activity_type_id integer,
    CONSTRAINT activities_pkey PRIMARY KEY (activity_id),
    CONSTRAINT unique_activity_title UNIQUE (title),
    CONSTRAINT unique_activity_title_per_team UNIQUE (team_id, title)
);

CREATE TABLE IF NOT EXISTS public.activity_types
(
    activity_type_id serial NOT NULL,
    activity_type_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT activity_types_pkey PRIMARY KEY (activity_type_id),
    CONSTRAINT activity_types_activity_type_name_key UNIQUE (activity_type_name)
);

CREATE TABLE IF NOT EXISTS public.activitylocations
(
    activity_location_id serial NOT NULL,
    activity_id integer,
    location_id integer,
    location_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    sequence_order integer,
    estimated_arrival_time timestamp without time zone,
    estimated_departure_time timestamp without time zone,
    is_public boolean DEFAULT true,
    notes text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT activitylocations_pkey PRIMARY KEY (activity_location_id)
);

CREATE TABLE IF NOT EXISTS public.activityresources
(
    activity_resource_id serial NOT NULL,
    activity_id integer,
    resource_id integer,
    quantity_required integer NOT NULL,
    notes text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT activityresources_pkey PRIMARY KEY (activity_resource_id)
);

CREATE TABLE IF NOT EXISTS public.activityroutes
(
    activity_route_id serial NOT NULL,
    activity_id integer,
    route_id integer,
    direction character varying(20) COLLATE pg_catalog."default" DEFAULT 'normal'::character varying,
    include_full_route boolean DEFAULT true,
    start_point_km numeric(8, 2),
    end_point_km numeric(8, 2),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT activityroutes_pkey PRIMARY KEY (activity_route_id)
);

CREATE TABLE IF NOT EXISTS public.auditlogs
(
    log_id serial NOT NULL,
    user_id integer,
    action_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    entity_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    entity_id integer NOT NULL,
    description text COLLATE pg_catalog."default",
    ip_address character varying(45) COLLATE pg_catalog."default",
    user_agent text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT auditlogs_pkey PRIMARY KEY (log_id)
);

CREATE TABLE IF NOT EXISTS public.certifications
(
    certification_id serial NOT NULL,
    user_id integer,
    certification_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    issuing_organization character varying(255) COLLATE pg_catalog."default" NOT NULL,
    issue_date date NOT NULL,
    expiration_date date,
    document_url character varying(255) COLLATE pg_catalog."default",
    is_verified boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT certifications_pkey PRIMARY KEY (certification_id)
);

CREATE TABLE IF NOT EXISTS public.committeeroles
(
    committee_role_id serial NOT NULL,
    user_id integer,
    role_level integer NOT NULL,
    appointed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT committeeroles_pkey PRIMARY KEY (committee_role_id),
    CONSTRAINT committeeroles_user_id_key UNIQUE (user_id)
);

CREATE TABLE IF NOT EXISTS public.communications
(
    communication_id serial NOT NULL,
    sender_id integer,
    recipient_id integer,
    team_id integer,
    activity_id integer,
    expedition_id integer,
    message_type character varying(50) COLLATE pg_catalog."default",
    subject character varying(255) COLLATE pg_catalog."default",
    message_content text COLLATE pg_catalog."default" NOT NULL,
    is_read boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT communications_pkey PRIMARY KEY (communication_id)
);

CREATE TABLE IF NOT EXISTS public.disputeresolutiontemplates
(
    template_id serial NOT NULL,
    template_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    dispute_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    resolution_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    template_text text COLLATE pg_catalog."default" NOT NULL,
    auto_approval_threshold numeric(10, 2),
    required_committee_level integer DEFAULT 3,
    created_by integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT disputeresolutiontemplates_pkey PRIMARY KEY (template_id)
);

CREATE TABLE IF NOT EXISTS public.disputeresponses
(
    response_id serial NOT NULL,
    dispute_id integer,
    responder_id integer,
    responder_role character varying(50) COLLATE pg_catalog."default" NOT NULL,
    response_text text COLLATE pg_catalog."default" NOT NULL,
    evidence_urls text[] COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT disputeresponses_pkey PRIMARY KEY (response_id)
);

CREATE TABLE IF NOT EXISTS public.earningssummaries
(
    summary_id serial NOT NULL,
    guide_id integer,
    team_id integer,
    year integer NOT NULL,
    month integer NOT NULL,
    total_earnings numeric(12, 2) NOT NULL,
    total_team_share numeric(12, 2) NOT NULL,
    total_commission numeric(12, 2) NOT NULL,
    activity_count integer DEFAULT 0,
    expedition_count integer DEFAULT 0,
    participant_count integer DEFAULT 0,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT earningssummaries_pkey PRIMARY KEY (summary_id),
    CONSTRAINT earningssummaries_guide_id_team_id_year_month_key UNIQUE (guide_id, team_id, year, month)
);

CREATE TABLE IF NOT EXISTS public.enforcementactions
(
    action_id serial NOT NULL,
    reported_issue_id integer,
    user_id integer,
    team_id integer,
    action_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    reason text COLLATE pg_catalog."default" NOT NULL,
    evidence text COLLATE pg_catalog."default",
    effective_from timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    effective_until timestamp without time zone,
    committee_member_id integer NOT NULL,
    committee_role_level integer NOT NULL,
    review_date timestamp without time zone,
    appeal_status character varying(20) COLLATE pg_catalog."default" DEFAULT 'not_appealed'::character varying,
    appeal_details text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT enforcementactions_pkey PRIMARY KEY (action_id)
);

CREATE TABLE IF NOT EXISTS public.eventrefundpolicies
(
    event_policy_id serial NOT NULL,
    activity_id integer,
    expedition_id integer,
    policy_id integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT eventrefundpolicies_pkey PRIMARY KEY (event_policy_id)
);

CREATE TABLE IF NOT EXISTS public.expeditionactivities
(
    expedition_activity_id serial NOT NULL,
    expedition_id integer,
    activity_id integer,
    sequence_order integer NOT NULL,
    day_number integer NOT NULL,
    start_time time without time zone,
    end_time time without time zone,
    is_optional boolean DEFAULT false,
    notes text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT expeditionactivities_pkey PRIMARY KEY (expedition_activity_id),
    CONSTRAINT expeditionactivities_expedition_id_activity_id_key UNIQUE (expedition_id, activity_id)
);

CREATE TABLE IF NOT EXISTS public.expeditionlocations
(
    expedition_location_id serial NOT NULL,
    expedition_id integer,
    location_id integer,
    location_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    sequence_order integer,
    arrival_date date,
    departure_date date,
    accommodation_details text COLLATE pg_catalog."default",
    is_public boolean DEFAULT true,
    notes text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT expeditionlocations_pkey PRIMARY KEY (expedition_location_id)
);

CREATE TABLE IF NOT EXISTS public.expeditionresources
(
    expedition_resource_id serial NOT NULL,
    expedition_id integer,
    resource_id integer,
    quantity_required integer NOT NULL,
    notes text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT expeditionresources_pkey PRIMARY KEY (expedition_resource_id)
);

CREATE TABLE IF NOT EXISTS public.expeditionroutes
(
    expedition_route_id serial NOT NULL,
    expedition_id integer,
    total_distance_km numeric(8, 2),
    total_travel_time_hours numeric(6, 2),
    route_points text COLLATE pg_catalog."default",
    route_summary text COLLATE pg_catalog."default",
    map_image_url character varying(255) COLLATE pg_catalog."default",
    last_calculated timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT expeditionroutes_pkey PRIMARY KEY (expedition_route_id),
    CONSTRAINT expeditionroutes_expedition_id_key UNIQUE (expedition_id)
);

CREATE TABLE IF NOT EXISTS public.expeditions
(
    expedition_id serial NOT NULL,
    team_id integer,
    title character varying(255) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default" NOT NULL,
    start_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone NOT NULL,
    min_participants integer DEFAULT 1,
    max_participants integer NOT NULL,
    price numeric(10, 2) NOT NULL,
    created_by integer,
    leader_id integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    expedition_status character varying(20) COLLATE pg_catalog."default" DEFAULT 'active'::character varying,
    CONSTRAINT expeditions_pkey PRIMARY KEY (expedition_id)
);

CREATE TABLE IF NOT EXISTS public.guideearnings
(
    earning_id serial NOT NULL,
    guide_id integer,
    team_id integer,
    payment_id integer,
    reservation_id integer,
    activity_id integer,
    expedition_id integer,
    amount numeric(10, 2) NOT NULL,
    team_share_amount numeric(10, 2) NOT NULL,
    commission_amount numeric(10, 2) NOT NULL,
    earnings_status character varying(20) COLLATE pg_catalog."default" DEFAULT 'pending'::character varying,
    payment_date timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT guideearnings_pkey PRIMARY KEY (earning_id)
);

CREATE TABLE IF NOT EXISTS public.guidemetrics
(
    metric_id serial NOT NULL,
    guide_id integer,
    total_activities_led integer DEFAULT 0,
    total_expeditions_led integer DEFAULT 0,
    total_participants_led integer DEFAULT 0,
    activities_completed integer DEFAULT 0,
    activities_canceled integer DEFAULT 0,
    expeditions_completed integer DEFAULT 0,
    expeditions_canceled integer DEFAULT 0,
    total_rating_sum integer DEFAULT 0,
    total_ratings_count integer DEFAULT 0,
    avg_rating numeric(3, 2) GENERATED ALWAYS AS (
CASE
    WHEN (total_ratings_count > 0) THEN ((total_rating_sum)::numeric / (total_ratings_count)::numeric)
    ELSE (0)::numeric
END) STORED,
    safety_incidents_count integer DEFAULT 0,
    last_activity_date timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT guidemetrics_pkey PRIMARY KEY (metric_id),
    CONSTRAINT guidemetrics_guide_id_key UNIQUE (guide_id)
);

CREATE TABLE IF NOT EXISTS public.guidepayoutdetails
(
    detail_id serial NOT NULL,
    payout_id integer,
    earning_id integer,
    amount numeric(10, 2) NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT guidepayoutdetails_pkey PRIMARY KEY (detail_id)
);

CREATE TABLE IF NOT EXISTS public.guidepayouts
(
    payout_id serial NOT NULL,
    guide_id integer,
    amount numeric(10, 2) NOT NULL,
    payment_method character varying(50) COLLATE pg_catalog."default" NOT NULL,
    reference_number character varying(255) COLLATE pg_catalog."default",
    status character varying(20) COLLATE pg_catalog."default" DEFAULT 'processing'::character varying,
    notes text COLLATE pg_catalog."default",
    payout_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT guidepayouts_pkey PRIMARY KEY (payout_id)
);

CREATE TABLE IF NOT EXISTS public.guideratings
(
    rating_id serial NOT NULL,
    guide_id integer,
    reservation_id integer,
    activity_id integer,
    expedition_id integer,
    rating integer NOT NULL,
    comment text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT guideratings_pkey PRIMARY KEY (rating_id)
);

CREATE TABLE IF NOT EXISTS public.guideregistrationrequests
(
    request_id serial NOT NULL,
    user_id integer,
    team_id integer,
    request_status character varying(20) COLLATE pg_catalog."default" DEFAULT 'pending'::character varying,
    tactical_guide_approval boolean DEFAULT false,
    master_guide_approval boolean DEFAULT false,
    request_message text COLLATE pg_catalog."default",
    response_message text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    responded_by integer,
    CONSTRAINT guideregistrationrequests_pkey PRIMARY KEY (request_id)
);

CREATE TABLE IF NOT EXISTS public.hashtags
(
    hashtag_id serial NOT NULL,
    name character varying(50) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT hashtags_pkey PRIMARY KEY (hashtag_id),
    CONSTRAINT hashtags_name_key UNIQUE (name)
);

CREATE TABLE IF NOT EXISTS public.invitation_codes
(
    code_id serial NOT NULL,
    code character varying(20) COLLATE pg_catalog."default" NOT NULL,
    role_type character varying(20) COLLATE pg_catalog."default" NOT NULL,
    team_id integer,
    created_by integer,
    max_uses integer DEFAULT 1,
    used_count integer DEFAULT 0,
    expires_at timestamp without time zone,
    is_active boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT invitation_codes_pkey PRIMARY KEY (code_id),
    CONSTRAINT invitation_codes_code_key UNIQUE (code)
);

CREATE TABLE IF NOT EXISTS public.invitation_usages
(
    usage_id serial NOT NULL,
    code_id integer,
    user_id integer,
    used_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT invitation_usages_pkey PRIMARY KEY (usage_id)
);

CREATE TABLE IF NOT EXISTS public.location_aliases
(
    alias_id serial NOT NULL,
    location_id integer,
    alias_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    language_code character varying(2) COLLATE pg_catalog."default",
    is_primary boolean,
    created_at timestamp without time zone,
    CONSTRAINT location_aliases_pkey PRIMARY KEY (alias_id)
);


CREATE TABLE IF NOT EXISTS public.locationfeatures
(
    feature_id serial NOT NULL,
    location_id integer,
    feature_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    feature_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    is_seasonal boolean DEFAULT false,
    season_start_month integer,
    season_end_month integer,
    last_verified_date date,
    verified_by integer,
    latitude numeric(10, 8),
    longitude numeric(11, 8),
    elevation_meters numeric(8, 2),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT locationfeatures_pkey PRIMARY KEY (feature_id)
);

CREATE TABLE IF NOT EXISTS public.locations
(
    location_id serial NOT NULL,
    location_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    location_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    latitude numeric(10, 8) NOT NULL,
    longitude numeric(11, 8) NOT NULL,
    elevation_meters numeric(8, 2),
    parent_location_id integer,
    country_code character(2) COLLATE pg_catalog."default",
    region_code character varying(10) COLLATE pg_catalog."default",
    postal_code character varying(20) COLLATE pg_catalog."default",
    formatted_address text COLLATE pg_catalog."default",
    is_verified boolean DEFAULT false,
    geojson text COLLATE pg_catalog."default",
    timezone character varying(50) COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT locations_pkey PRIMARY KEY (location_id)
);

CREATE TABLE IF NOT EXISTS public.master_guide_activity_monitor
(
    monitor_id integer NOT NULL DEFAULT nextval('masterguideactivitymonitor_monitor_id_seq'::regclass),
    master_guide_id integer,
    team_id integer,
    last_login timestamp without time zone,
    last_event_created timestamp without time zone,
    last_reservation_managed timestamp without time zone,
    inactivity_warning_sent boolean DEFAULT false,
    inactivity_warning_date timestamp without time zone,
    inactive_status boolean DEFAULT false,
    inactive_since timestamp without time zone,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT masterguideactivitymonitor_pkey PRIMARY KEY (monitor_id),
    CONSTRAINT masterguideactivitymonitor_master_guide_id_team_id_key UNIQUE (master_guide_id, team_id)
);

CREATE TABLE IF NOT EXISTS public.micrositecontentsections
(
    section_id serial NOT NULL,
    microsite_id integer,
    section_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    title character varying(255) COLLATE pg_catalog."default",
    content text COLLATE pg_catalog."default",
    display_order integer,
    is_visible boolean DEFAULT true,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT micrositecontentsections_pkey PRIMARY KEY (section_id)
);

CREATE TABLE IF NOT EXISTS public.micrositeposts
(
    post_id serial NOT NULL,
    microsite_id integer,
    title character varying(255) COLLATE pg_catalog."default" NOT NULL,
    content text COLLATE pg_catalog."default" NOT NULL,
    post_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    activity_id integer,
    expedition_id integer,
    is_featured boolean DEFAULT false,
    is_published boolean DEFAULT true,
    likes_count integer DEFAULT 0,
    comments_count integer DEFAULT 0,
    saves_count integer DEFAULT 0,
    created_by integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT micrositeposts_pkey PRIMARY KEY (post_id)
);

CREATE TABLE IF NOT EXISTS public.new_feature
(
    id serial NOT NULL,
    name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default" NOT NULL,
    created_by integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT new_feature_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS public.paymentdisputes
(
    dispute_id serial NOT NULL,
    payment_id integer,
    reservation_id integer,
    user_id integer,
    dispute_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    status character varying(20) COLLATE pg_catalog."default" DEFAULT 'open'::character varying,
    dispute_details text COLLATE pg_catalog."default" NOT NULL,
    evidence_urls text[] COLLATE pg_catalog."default",
    dispute_amount numeric(10, 2) NOT NULL,
    filed_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    assigned_to integer,
    resolution_type character varying(50) COLLATE pg_catalog."default",
    resolution_details text COLLATE pg_catalog."default",
    resolution_date timestamp without time zone,
    is_auto_approved boolean DEFAULT false,
    notified_parties text[] COLLATE pg_catalog."default",
    last_notification_date timestamp without time zone,
    response_deadline timestamp without time zone,
    escalation_level integer DEFAULT 1,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT paymentdisputes_pkey PRIMARY KEY (dispute_id)
);

CREATE TABLE IF NOT EXISTS public.payments
(
    payment_id serial NOT NULL,
    reservation_id integer,
    amount numeric(10, 2) NOT NULL,
    payment_method character varying(50) COLLATE pg_catalog."default" NOT NULL,
    transaction_id character varying(255) COLLATE pg_catalog."default",
    payment_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    payment_status character varying(20) COLLATE pg_catalog."default" NOT NULL,
    gateway_response text COLLATE pg_catalog."default",
    refund_amount numeric(10, 2) DEFAULT 0,
    refund_reason text COLLATE pg_catalog."default",
    refund_date timestamp without time zone,
    refund_transaction_id character varying(255) COLLATE pg_catalog."default",
    refund_status character varying(20) COLLATE pg_catalog."default",
    refund_initiated_by integer,
    refund_method character varying(50) COLLATE pg_catalog."default",
    billing_address text COLLATE pg_catalog."default",
    billing_city character varying(100) COLLATE pg_catalog."default",
    billing_country character varying(100) COLLATE pg_catalog."default",
    billing_postal_code character varying(20) COLLATE pg_catalog."default",
    eligible_for_auto_refund boolean DEFAULT true,
    is_test_payment boolean DEFAULT false,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT payments_pkey PRIMARY KEY (payment_id),
    CONSTRAINT payments_transaction_id_key UNIQUE (transaction_id)
);

CREATE TABLE IF NOT EXISTS public.postcomments
(
    comment_id serial NOT NULL,
    post_id integer,
    user_id integer,
    parent_comment_id integer,
    content text COLLATE pg_catalog."default" NOT NULL,
    is_hidden boolean DEFAULT false,
    likes_count integer DEFAULT 0,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT postcomments_pkey PRIMARY KEY (comment_id)
);

CREATE TABLE IF NOT EXISTS public.posthashtags
(
    post_hashtag_id serial NOT NULL,
    post_id integer,
    hashtag_id integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT posthashtags_pkey PRIMARY KEY (post_hashtag_id),
    CONSTRAINT posthashtags_post_id_hashtag_id_key UNIQUE (post_id, hashtag_id)
);

CREATE TABLE IF NOT EXISTS public.postimages
(
    image_id serial NOT NULL,
    post_id integer,
    image_url character varying(255) COLLATE pg_catalog."default" NOT NULL,
    storage_provider character varying(50) COLLATE pg_catalog."default" NOT NULL,
    display_order integer NOT NULL,
    alt_text character varying(255) COLLATE pg_catalog."default",
    caption text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT postimages_pkey PRIMARY KEY (image_id),
    CONSTRAINT postimages_post_id_display_order_key UNIQUE (post_id, display_order)
);

CREATE TABLE IF NOT EXISTS public.postinteractions
(
    interaction_id serial NOT NULL,
    post_id integer,
    user_id integer,
    interaction_type character varying(20) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT postinteractions_pkey PRIMARY KEY (interaction_id),
    CONSTRAINT postinteractions_post_id_user_id_interaction_type_key UNIQUE (post_id, user_id, interaction_type)
);

CREATE TABLE IF NOT EXISTS public.profilevisibilitysettings
(
    setting_id serial NOT NULL,
    user_id integer,
    show_name boolean DEFAULT true,
    show_age boolean DEFAULT true,
    show_specialties boolean DEFAULT true,
    show_certifications_count integer DEFAULT 3,
    show_activity_count boolean DEFAULT true,
    show_full_qualifications boolean DEFAULT true,
    show_expedition_count boolean DEFAULT true,
    show_team_affiliation boolean DEFAULT true,
    show_role_level boolean DEFAULT true,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT profilevisibilitysettings_pkey PRIMARY KEY (setting_id),
    CONSTRAINT profilevisibilitysettings_user_id_key UNIQUE (user_id)
);

CREATE TABLE IF NOT EXISTS public.refundpolicies
(
    policy_id serial NOT NULL,
    team_id integer,
    policy_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    cancellation_window_hours integer NOT NULL,
    full_refund_cutoff_hours integer NOT NULL,
    partial_refund_percentage integer,
    partial_refund_cutoff_hours integer,
    no_refund_message text COLLATE pg_catalog."default",
    exceptions_allowed boolean DEFAULT true,
    exception_approval_required boolean DEFAULT true,
    is_active boolean DEFAULT true,
    created_by integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT refundpolicies_pkey PRIMARY KEY (policy_id)
);

CREATE TABLE IF NOT EXISTS public.reportedissues
(
    issue_id serial NOT NULL,
    reporter_id integer,
    reported_user_id integer,
    reported_team_id integer,
    related_activity_id integer,
    related_expedition_id integer,
    issue_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default" NOT NULL,
    severity_level integer DEFAULT 1,
    status character varying(20) COLLATE pg_catalog."default" DEFAULT 'pending'::character varying,
    assigned_to integer,
    resolution_notes text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT reportedissues_pkey PRIMARY KEY (issue_id)
);

CREATE TABLE IF NOT EXISTS public.reservationparticipants
(
    participant_id serial NOT NULL,
    reservation_id integer,
    user_id integer,
    first_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    last_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    email character varying(255) COLLATE pg_catalog."default" NOT NULL,
    emergency_contact_name character varying(255) COLLATE pg_catalog."default",
    emergency_contact_phone character varying(50) COLLATE pg_catalog."default",
    CONSTRAINT reservationparticipants_pkey PRIMARY KEY (participant_id)
);

CREATE TABLE IF NOT EXISTS public.reservations
(
    reservation_id serial NOT NULL,
    user_id integer,
    activity_id integer,
    expedition_id integer,
    reservation_date timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    participant_count integer DEFAULT 1,
    total_price numeric(10, 2) NOT NULL,
    commission_amount numeric(10, 2) NOT NULL,
    status character varying(20) COLLATE pg_catalog."default" DEFAULT 'pending'::character varying,
    denial_reason character varying(100) COLLATE pg_catalog."default",
    payment_status character varying(20) COLLATE pg_catalog."default" DEFAULT 'unpaid'::character varying,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    activity_start_datetime timestamp without time zone,
    activity_end_datetime timestamp without time zone,
    CONSTRAINT reservations_pkey PRIMARY KEY (reservation_id)
);

CREATE TABLE IF NOT EXISTS public.resourcecategories
(
    category_id serial NOT NULL,
    team_id integer,
    category_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    created_by integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT resourcecategories_pkey PRIMARY KEY (category_id),
    CONSTRAINT resourcecategories_team_id_category_name_key UNIQUE (team_id, category_name)
);

CREATE TABLE IF NOT EXISTS public.resources
(
    resource_id serial NOT NULL,
    team_id integer,
    category_id integer,
    resource_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    description text COLLATE pg_catalog."default",
    quantity integer NOT NULL,
    unit_cost numeric(10, 2),
    created_by integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT resources_pkey PRIMARY KEY (resource_id)
);

CREATE TABLE IF NOT EXISTS public.rolepermissions
(
    permission_id serial NOT NULL,
    team_id integer,
    role_level integer NOT NULL,
    permission_type character varying(100) COLLATE pg_catalog."default" NOT NULL,
    is_enabled boolean DEFAULT true,
    modified_by integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT rolepermissions_pkey PRIMARY KEY (permission_id),
    CONSTRAINT rolepermissions_team_id_role_level_permission_type_key UNIQUE (team_id, role_level, permission_type)
);

CREATE TABLE IF NOT EXISTS public.routes
(
    route_id serial NOT NULL,
    route_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    route_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    total_distance_km numeric(8, 2),
    elevation_gain_m numeric(8, 2),
    elevation_loss_m numeric(8, 2),
    difficulty_level character varying(20) COLLATE pg_catalog."default",
    estimated_duration_minutes integer,
    start_location_id integer,
    end_location_id integer,
    geojson text COLLATE pg_catalog."default",
    is_loop boolean DEFAULT false,
    is_verified boolean DEFAULT false,
    created_by integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT routes_pkey PRIMARY KEY (route_id)
);

CREATE TABLE IF NOT EXISTS public.team_members
(
    team_member_id serial NOT NULL,
    team_id integer,
    user_id integer,
    role_level integer NOT NULL,
    joined_at timestamp without time zone,
    updated_at timestamp without time zone,
    CONSTRAINT team_members_pkey PRIMARY KEY (team_member_id),
    CONSTRAINT team_members_team_id_user_id_key UNIQUE (team_id, user_id)
);

CREATE TABLE IF NOT EXISTS public.team_role_configurations
(
    role_config_id serial NOT NULL,
    team_id integer,
    level_1_name character varying(100) COLLATE pg_catalog."default",
    level_2_name character varying(100) COLLATE pg_catalog."default",
    level_3_name character varying(100) COLLATE pg_catalog."default",
    level_4_name character varying(100) COLLATE pg_catalog."default",
    updated_at timestamp without time zone,
    CONSTRAINT team_role_configurations_pkey PRIMARY KEY (role_config_id)
);

CREATE TABLE IF NOT EXISTS public.teammetrics
(
    metric_id serial NOT NULL,
    team_id integer,
    current_reservation_count integer DEFAULT 0,
    reservation_limit integer DEFAULT 100,
    total_events_count integer DEFAULT 0,
    total_activities_count integer DEFAULT 0,
    total_expeditions_count integer DEFAULT 0,
    total_revenue numeric(12, 2) DEFAULT 0,
    total_commission_paid numeric(12, 2) DEFAULT 0,
    custom_commission_rate numeric(5, 2),
    commission_rate_negotiated boolean DEFAULT false,
    limit_negotiation_date timestamp without time zone,
    limit_approved_by integer,
    last_updated timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT teammetrics_pkey PRIMARY KEY (metric_id),
    CONSTRAINT teammetrics_team_id_key UNIQUE (team_id)
);

CREATE TABLE IF NOT EXISTS public.teammicrosites
(
    microsite_id serial NOT NULL,
    team_id integer,
    site_title character varying(255) COLLATE pg_catalog."default" NOT NULL,
    site_description text COLLATE pg_catalog."default",
    theme_color character varying(20) COLLATE pg_catalog."default",
    logo_url character varying(255) COLLATE pg_catalog."default",
    contact_email character varying(255) COLLATE pg_catalog."default",
    contact_phone character varying(50) COLLATE pg_catalog."default",
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT teammicrosites_pkey PRIMARY KEY (microsite_id),
    CONSTRAINT teammicrosites_team_id_key UNIQUE (team_id)
);

CREATE TABLE IF NOT EXISTS public.teamrevenuesharing
(
    sharing_id serial NOT NULL,
    team_id integer,
    role_level integer NOT NULL,
    percentage numeric(5, 2) NOT NULL,
    modified_by integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT teamrevenuesharing_pkey PRIMARY KEY (sharing_id),
    CONSTRAINT teamrevenuesharing_team_id_role_level_key UNIQUE (team_id, role_level)
);

CREATE TABLE IF NOT EXISTS public.teamroleconfigurations
(
    role_config_id serial NOT NULL,
    team_id integer,
    level_1_name character varying(100) COLLATE pg_catalog."default" DEFAULT 'Master Guide'::character varying,
    level_2_name character varying(100) COLLATE pg_catalog."default" DEFAULT 'Tactical Guide'::character varying,
    level_3_name character varying(100) COLLATE pg_catalog."default" DEFAULT 'Technical Guide'::character varying,
    level_4_name character varying(100) COLLATE pg_catalog."default" DEFAULT 'Base Guide'::character varying,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT teamroleconfigurations_pkey PRIMARY KEY (role_config_id)
);

CREATE TABLE IF NOT EXISTS public.teams
(
    team_id serial NOT NULL,
    team_name character varying(255) COLLATE pg_catalog."default" NOT NULL,
    master_guide_id integer,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    team_status character varying(20) COLLATE pg_catalog."default" DEFAULT 'active'::character varying,
    CONSTRAINT teams_pkey PRIMARY KEY (team_id),
    CONSTRAINT teams_team_name_key UNIQUE (team_name)
);

CREATE TABLE IF NOT EXISTS public.user_roles
(
    user_role_id serial NOT NULL,
    user_id integer,
    role_type character varying(20) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone,
    CONSTRAINT user_roles_pkey PRIMARY KEY (user_role_id),
    CONSTRAINT user_roles_user_id_role_type_key UNIQUE (user_id, role_type)
);

CREATE TABLE IF NOT EXISTS public.useractivitylogs
(
    activity_log_id serial NOT NULL,
    user_id integer,
    activity_type character varying(50) COLLATE pg_catalog."default" NOT NULL,
    ip_address character varying(45) COLLATE pg_catalog."default",
    user_agent text COLLATE pg_catalog."default",
    device_info text COLLATE pg_catalog."default",
    location_data text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT useractivitylogs_pkey PRIMARY KEY (activity_log_id)
);

CREATE TABLE IF NOT EXISTS public.userroles
(
    user_role_id serial NOT NULL,
    user_id integer,
    role_type character varying(20) COLLATE pg_catalog."default" NOT NULL,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT userroles_pkey PRIMARY KEY (user_role_id),
    CONSTRAINT userroles_user_id_role_type_key UNIQUE (user_id, role_type)
);

CREATE TABLE IF NOT EXISTS public.users
(
    user_id serial NOT NULL,
    email character varying(255) COLLATE pg_catalog."default" NOT NULL,
    password_hash character varying(255) COLLATE pg_catalog."default" NOT NULL,
    first_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    last_name character varying(100) COLLATE pg_catalog."default" NOT NULL,
    date_of_birth date NOT NULL,
    profile_visibility boolean DEFAULT true,
    profile_image_url character varying(255) COLLATE pg_catalog."default",
    bio text COLLATE pg_catalog."default",
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    last_login timestamp without time zone,
    national_id character varying(20) COLLATE pg_catalog."default",
    phone_number character varying(20) COLLATE pg_catalog."default",
    account_status character varying(20) COLLATE pg_catalog."default" DEFAULT 'active'::character varying,
    CONSTRAINT users_pkey PRIMARY KEY (user_id),
    CONSTRAINT users_email_key UNIQUE (email)
);

ALTER TABLE IF EXISTS public.activities
    ADD CONSTRAINT activities_activity_type_id_fkey FOREIGN KEY (activity_type_id)
    REFERENCES public.activity_types (activity_type_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.activities
    ADD CONSTRAINT activities_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.activities
    ADD CONSTRAINT activities_leader_id_fkey FOREIGN KEY (leader_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_activities_leader_id
    ON public.activities(leader_id);


ALTER TABLE IF EXISTS public.activities
    ADD CONSTRAINT activities_location_id_fkey FOREIGN KEY (location_id)
    REFERENCES public.locations (location_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_activities_location_id
    ON public.activities(location_id);


ALTER TABLE IF EXISTS public.activities
    ADD CONSTRAINT activities_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_activities_team_id
    ON public.activities(team_id);


ALTER TABLE IF EXISTS public.activitylocations
    ADD CONSTRAINT activitylocations_activity_id_fkey FOREIGN KEY (activity_id)
    REFERENCES public.activities (activity_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.activitylocations
    ADD CONSTRAINT activitylocations_location_id_fkey FOREIGN KEY (location_id)
    REFERENCES public.locations (location_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.activityresources
    ADD CONSTRAINT activityresources_activity_id_fkey FOREIGN KEY (activity_id)
    REFERENCES public.activities (activity_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.activityresources
    ADD CONSTRAINT activityresources_resource_id_fkey FOREIGN KEY (resource_id)
    REFERENCES public.resources (resource_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.activityroutes
    ADD CONSTRAINT activityroutes_activity_id_fkey FOREIGN KEY (activity_id)
    REFERENCES public.activities (activity_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.activityroutes
    ADD CONSTRAINT activityroutes_route_id_fkey FOREIGN KEY (route_id)
    REFERENCES public.routes (route_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.auditlogs
    ADD CONSTRAINT auditlogs_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.certifications
    ADD CONSTRAINT certifications_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.committeeroles
    ADD CONSTRAINT committeeroles_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS committeeroles_user_id_key
    ON public.committeeroles(user_id);


ALTER TABLE IF EXISTS public.communications
    ADD CONSTRAINT communications_activity_id_fkey FOREIGN KEY (activity_id)
    REFERENCES public.activities (activity_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.communications
    ADD CONSTRAINT communications_expedition_id_fkey FOREIGN KEY (expedition_id)
    REFERENCES public.expeditions (expedition_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.communications
    ADD CONSTRAINT communications_recipient_id_fkey FOREIGN KEY (recipient_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_communications_recipient_id
    ON public.communications(recipient_id);


ALTER TABLE IF EXISTS public.communications
    ADD CONSTRAINT communications_sender_id_fkey FOREIGN KEY (sender_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.communications
    ADD CONSTRAINT communications_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_communications_team_id
    ON public.communications(team_id);


ALTER TABLE IF EXISTS public.disputeresolutiontemplates
    ADD CONSTRAINT disputeresolutiontemplates_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.disputeresponses
    ADD CONSTRAINT disputeresponses_dispute_id_fkey FOREIGN KEY (dispute_id)
    REFERENCES public.paymentdisputes (dispute_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.disputeresponses
    ADD CONSTRAINT disputeresponses_responder_id_fkey FOREIGN KEY (responder_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.earningssummaries
    ADD CONSTRAINT earningssummaries_guide_id_fkey FOREIGN KEY (guide_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_earnings_summaries_guide_id
    ON public.earningssummaries(guide_id);


ALTER TABLE IF EXISTS public.earningssummaries
    ADD CONSTRAINT earningssummaries_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_earnings_summaries_team_id
    ON public.earningssummaries(team_id);


ALTER TABLE IF EXISTS public.enforcementactions
    ADD CONSTRAINT enforcementactions_committee_member_id_fkey FOREIGN KEY (committee_member_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.enforcementactions
    ADD CONSTRAINT enforcementactions_reported_issue_id_fkey FOREIGN KEY (reported_issue_id)
    REFERENCES public.reportedissues (issue_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.enforcementactions
    ADD CONSTRAINT enforcementactions_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_enforcement_actions_team_id
    ON public.enforcementactions(team_id);


ALTER TABLE IF EXISTS public.enforcementactions
    ADD CONSTRAINT enforcementactions_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_enforcement_actions_user_id
    ON public.enforcementactions(user_id);


ALTER TABLE IF EXISTS public.eventrefundpolicies
    ADD CONSTRAINT eventrefundpolicies_activity_id_fkey FOREIGN KEY (activity_id)
    REFERENCES public.activities (activity_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.eventrefundpolicies
    ADD CONSTRAINT eventrefundpolicies_expedition_id_fkey FOREIGN KEY (expedition_id)
    REFERENCES public.expeditions (expedition_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.eventrefundpolicies
    ADD CONSTRAINT eventrefundpolicies_policy_id_fkey FOREIGN KEY (policy_id)
    REFERENCES public.refundpolicies (policy_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.expeditionactivities
    ADD CONSTRAINT expeditionactivities_activity_id_fkey FOREIGN KEY (activity_id)
    REFERENCES public.activities (activity_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_expedition_activities_activity_id
    ON public.expeditionactivities(activity_id);


ALTER TABLE IF EXISTS public.expeditionactivities
    ADD CONSTRAINT expeditionactivities_expedition_id_fkey FOREIGN KEY (expedition_id)
    REFERENCES public.expeditions (expedition_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_expedition_activities_expedition_id
    ON public.expeditionactivities(expedition_id);


ALTER TABLE IF EXISTS public.expeditionlocations
    ADD CONSTRAINT expeditionlocations_expedition_id_fkey FOREIGN KEY (expedition_id)
    REFERENCES public.expeditions (expedition_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.expeditionlocations
    ADD CONSTRAINT expeditionlocations_location_id_fkey FOREIGN KEY (location_id)
    REFERENCES public.locations (location_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.expeditionresources
    ADD CONSTRAINT expeditionresources_expedition_id_fkey FOREIGN KEY (expedition_id)
    REFERENCES public.expeditions (expedition_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.expeditionresources
    ADD CONSTRAINT expeditionresources_resource_id_fkey FOREIGN KEY (resource_id)
    REFERENCES public.resources (resource_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.expeditionroutes
    ADD CONSTRAINT expeditionroutes_expedition_id_fkey FOREIGN KEY (expedition_id)
    REFERENCES public.expeditions (expedition_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS expeditionroutes_expedition_id_key
    ON public.expeditionroutes(expedition_id);


ALTER TABLE IF EXISTS public.expeditions
    ADD CONSTRAINT expeditions_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.expeditions
    ADD CONSTRAINT expeditions_leader_id_fkey FOREIGN KEY (leader_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_expeditions_leader_id
    ON public.expeditions(leader_id);


ALTER TABLE IF EXISTS public.expeditions
    ADD CONSTRAINT expeditions_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_expeditions_team_id
    ON public.expeditions(team_id);


ALTER TABLE IF EXISTS public.guideearnings
    ADD CONSTRAINT guideearnings_activity_id_fkey FOREIGN KEY (activity_id)
    REFERENCES public.activities (activity_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.guideearnings
    ADD CONSTRAINT guideearnings_expedition_id_fkey FOREIGN KEY (expedition_id)
    REFERENCES public.expeditions (expedition_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.guideearnings
    ADD CONSTRAINT guideearnings_guide_id_fkey FOREIGN KEY (guide_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_guide_earnings_guide_id
    ON public.guideearnings(guide_id);


ALTER TABLE IF EXISTS public.guideearnings
    ADD CONSTRAINT guideearnings_payment_id_fkey FOREIGN KEY (payment_id)
    REFERENCES public.payments (payment_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_guide_earnings_payment_id
    ON public.guideearnings(payment_id);


ALTER TABLE IF EXISTS public.guideearnings
    ADD CONSTRAINT guideearnings_reservation_id_fkey FOREIGN KEY (reservation_id)
    REFERENCES public.reservations (reservation_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_guide_earnings_reservation_id
    ON public.guideearnings(reservation_id);


ALTER TABLE IF EXISTS public.guideearnings
    ADD CONSTRAINT guideearnings_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_guide_earnings_team_id
    ON public.guideearnings(team_id);


ALTER TABLE IF EXISTS public.guidemetrics
    ADD CONSTRAINT guidemetrics_guide_id_fkey FOREIGN KEY (guide_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS guidemetrics_guide_id_key
    ON public.guidemetrics(guide_id);


ALTER TABLE IF EXISTS public.guidepayoutdetails
    ADD CONSTRAINT guidepayoutdetails_earning_id_fkey FOREIGN KEY (earning_id)
    REFERENCES public.guideearnings (earning_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_guide_payout_details_earning_id
    ON public.guidepayoutdetails(earning_id);


ALTER TABLE IF EXISTS public.guidepayoutdetails
    ADD CONSTRAINT guidepayoutdetails_payout_id_fkey FOREIGN KEY (payout_id)
    REFERENCES public.guidepayouts (payout_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_guide_payout_details_payout_id
    ON public.guidepayoutdetails(payout_id);


ALTER TABLE IF EXISTS public.guidepayouts
    ADD CONSTRAINT guidepayouts_guide_id_fkey FOREIGN KEY (guide_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_guide_payouts_guide_id
    ON public.guidepayouts(guide_id);


ALTER TABLE IF EXISTS public.guideratings
    ADD CONSTRAINT guideratings_activity_id_fkey FOREIGN KEY (activity_id)
    REFERENCES public.activities (activity_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_guide_ratings_activity_id
    ON public.guideratings(activity_id);


ALTER TABLE IF EXISTS public.guideratings
    ADD CONSTRAINT guideratings_expedition_id_fkey FOREIGN KEY (expedition_id)
    REFERENCES public.expeditions (expedition_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_guide_ratings_expedition_id
    ON public.guideratings(expedition_id);


ALTER TABLE IF EXISTS public.guideratings
    ADD CONSTRAINT guideratings_guide_id_fkey FOREIGN KEY (guide_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_guide_ratings_guide_id
    ON public.guideratings(guide_id);


ALTER TABLE IF EXISTS public.guideratings
    ADD CONSTRAINT guideratings_reservation_id_fkey FOREIGN KEY (reservation_id)
    REFERENCES public.reservations (reservation_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_guide_ratings_reservation_id
    ON public.guideratings(reservation_id);


ALTER TABLE IF EXISTS public.guideregistrationrequests
    ADD CONSTRAINT guideregistrationrequests_responded_by_fkey FOREIGN KEY (responded_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.guideregistrationrequests
    ADD CONSTRAINT guideregistrationrequests_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.guideregistrationrequests
    ADD CONSTRAINT guideregistrationrequests_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.invitation_codes
    ADD CONSTRAINT invitation_codes_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.invitation_codes
    ADD CONSTRAINT invitation_codes_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.invitation_usages
    ADD CONSTRAINT invitation_usages_code_id_fkey FOREIGN KEY (code_id)
    REFERENCES public.invitation_codes (code_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_invitation_usages_code_id
    ON public.invitation_usages(code_id);


ALTER TABLE IF EXISTS public.invitation_usages
    ADD CONSTRAINT invitation_usages_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_invitation_usages_user_id
    ON public.invitation_usages(user_id);


ALTER TABLE IF EXISTS public.location_aliases
    ADD CONSTRAINT location_aliases_location_id_fkey FOREIGN KEY (location_id)
    REFERENCES public.locations (location_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.locationaliases
    ADD CONSTRAINT locationaliases_location_id_fkey FOREIGN KEY (location_id)
    REFERENCES public.locations (location_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.locationfeatures
    ADD CONSTRAINT locationfeatures_location_id_fkey FOREIGN KEY (location_id)
    REFERENCES public.locations (location_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.locationfeatures
    ADD CONSTRAINT locationfeatures_verified_by_fkey FOREIGN KEY (verified_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.locations
    ADD CONSTRAINT locations_parent_location_id_fkey FOREIGN KEY (parent_location_id)
    REFERENCES public.locations (location_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_locations_parent_id
    ON public.locations(parent_location_id);


ALTER TABLE IF EXISTS public.master_guide_activity_monitor
    ADD CONSTRAINT masterguideactivitymonitor_master_guide_id_fkey FOREIGN KEY (master_guide_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_master_guide_activity_monitor_guide_id
    ON public.master_guide_activity_monitor(master_guide_id);


ALTER TABLE IF EXISTS public.master_guide_activity_monitor
    ADD CONSTRAINT masterguideactivitymonitor_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.micrositecontentsections
    ADD CONSTRAINT micrositecontentsections_microsite_id_fkey FOREIGN KEY (microsite_id)
    REFERENCES public.teammicrosites (microsite_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.micrositeposts
    ADD CONSTRAINT micrositeposts_activity_id_fkey FOREIGN KEY (activity_id)
    REFERENCES public.activities (activity_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_micrositeposts_activity_id
    ON public.micrositeposts(activity_id);


ALTER TABLE IF EXISTS public.micrositeposts
    ADD CONSTRAINT micrositeposts_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.micrositeposts
    ADD CONSTRAINT micrositeposts_expedition_id_fkey FOREIGN KEY (expedition_id)
    REFERENCES public.expeditions (expedition_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_micrositeposts_expedition_id
    ON public.micrositeposts(expedition_id);


ALTER TABLE IF EXISTS public.micrositeposts
    ADD CONSTRAINT micrositeposts_microsite_id_fkey FOREIGN KEY (microsite_id)
    REFERENCES public.teammicrosites (microsite_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_micrositeposts_microsite_id
    ON public.micrositeposts(microsite_id);


ALTER TABLE IF EXISTS public.new_feature
    ADD CONSTRAINT new_feature_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.paymentdisputes
    ADD CONSTRAINT paymentdisputes_assigned_to_fkey FOREIGN KEY (assigned_to)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.paymentdisputes
    ADD CONSTRAINT paymentdisputes_payment_id_fkey FOREIGN KEY (payment_id)
    REFERENCES public.payments (payment_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_payment_disputes_payment_id
    ON public.paymentdisputes(payment_id);


ALTER TABLE IF EXISTS public.paymentdisputes
    ADD CONSTRAINT paymentdisputes_reservation_id_fkey FOREIGN KEY (reservation_id)
    REFERENCES public.reservations (reservation_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.paymentdisputes
    ADD CONSTRAINT paymentdisputes_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_payment_disputes_user_id
    ON public.paymentdisputes(user_id);


ALTER TABLE IF EXISTS public.payments
    ADD CONSTRAINT payments_refund_initiated_by_fkey FOREIGN KEY (refund_initiated_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.payments
    ADD CONSTRAINT payments_reservation_id_fkey FOREIGN KEY (reservation_id)
    REFERENCES public.reservations (reservation_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_payments_reservation_id
    ON public.payments(reservation_id);


ALTER TABLE IF EXISTS public.postcomments
    ADD CONSTRAINT postcomments_parent_comment_id_fkey FOREIGN KEY (parent_comment_id)
    REFERENCES public.postcomments (comment_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.postcomments
    ADD CONSTRAINT postcomments_post_id_fkey FOREIGN KEY (post_id)
    REFERENCES public.micrositeposts (post_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_postcomments_post_id
    ON public.postcomments(post_id);


ALTER TABLE IF EXISTS public.postcomments
    ADD CONSTRAINT postcomments_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.posthashtags
    ADD CONSTRAINT posthashtags_hashtag_id_fkey FOREIGN KEY (hashtag_id)
    REFERENCES public.hashtags (hashtag_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.posthashtags
    ADD CONSTRAINT posthashtags_post_id_fkey FOREIGN KEY (post_id)
    REFERENCES public.micrositeposts (post_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.postimages
    ADD CONSTRAINT postimages_post_id_fkey FOREIGN KEY (post_id)
    REFERENCES public.micrositeposts (post_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_postimages_post_id
    ON public.postimages(post_id);


ALTER TABLE IF EXISTS public.postinteractions
    ADD CONSTRAINT postinteractions_post_id_fkey FOREIGN KEY (post_id)
    REFERENCES public.micrositeposts (post_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_postinteractions_post_id
    ON public.postinteractions(post_id);


ALTER TABLE IF EXISTS public.postinteractions
    ADD CONSTRAINT postinteractions_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_postinteractions_user_id
    ON public.postinteractions(user_id);


ALTER TABLE IF EXISTS public.profilevisibilitysettings
    ADD CONSTRAINT profilevisibilitysettings_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS profilevisibilitysettings_user_id_key
    ON public.profilevisibilitysettings(user_id);


ALTER TABLE IF EXISTS public.refundpolicies
    ADD CONSTRAINT refundpolicies_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.refundpolicies
    ADD CONSTRAINT refundpolicies_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.reportedissues
    ADD CONSTRAINT reportedissues_assigned_to_fkey FOREIGN KEY (assigned_to)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.reportedissues
    ADD CONSTRAINT reportedissues_related_activity_id_fkey FOREIGN KEY (related_activity_id)
    REFERENCES public.activities (activity_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.reportedissues
    ADD CONSTRAINT reportedissues_related_expedition_id_fkey FOREIGN KEY (related_expedition_id)
    REFERENCES public.expeditions (expedition_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.reportedissues
    ADD CONSTRAINT reportedissues_reported_team_id_fkey FOREIGN KEY (reported_team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.reportedissues
    ADD CONSTRAINT reportedissues_reported_user_id_fkey FOREIGN KEY (reported_user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.reportedissues
    ADD CONSTRAINT reportedissues_reporter_id_fkey FOREIGN KEY (reporter_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.reservationparticipants
    ADD CONSTRAINT reservationparticipants_reservation_id_fkey FOREIGN KEY (reservation_id)
    REFERENCES public.reservations (reservation_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.reservationparticipants
    ADD CONSTRAINT reservationparticipants_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.reservations
    ADD CONSTRAINT reservations_activity_id_fkey FOREIGN KEY (activity_id)
    REFERENCES public.activities (activity_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_reservations_activity_id
    ON public.reservations(activity_id);


ALTER TABLE IF EXISTS public.reservations
    ADD CONSTRAINT reservations_expedition_id_fkey FOREIGN KEY (expedition_id)
    REFERENCES public.expeditions (expedition_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_reservations_expedition_id
    ON public.reservations(expedition_id);


ALTER TABLE IF EXISTS public.reservations
    ADD CONSTRAINT reservations_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_reservations_user_id
    ON public.reservations(user_id);


ALTER TABLE IF EXISTS public.resourcecategories
    ADD CONSTRAINT resourcecategories_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.resourcecategories
    ADD CONSTRAINT resourcecategories_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.resources
    ADD CONSTRAINT resources_category_id_fkey FOREIGN KEY (category_id)
    REFERENCES public.resourcecategories (category_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.resources
    ADD CONSTRAINT resources_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.resources
    ADD CONSTRAINT resources_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.rolepermissions
    ADD CONSTRAINT rolepermissions_modified_by_fkey FOREIGN KEY (modified_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.rolepermissions
    ADD CONSTRAINT rolepermissions_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.routes
    ADD CONSTRAINT routes_created_by_fkey FOREIGN KEY (created_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.routes
    ADD CONSTRAINT routes_end_location_id_fkey FOREIGN KEY (end_location_id)
    REFERENCES public.locations (location_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.routes
    ADD CONSTRAINT routes_start_location_id_fkey FOREIGN KEY (start_location_id)
    REFERENCES public.locations (location_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.team_members
    ADD CONSTRAINT team_members_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.team_members
    ADD CONSTRAINT team_members_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.team_role_configurations
    ADD CONSTRAINT team_role_configurations_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.teammetrics
    ADD CONSTRAINT teammetrics_limit_approved_by_fkey FOREIGN KEY (limit_approved_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.teammetrics
    ADD CONSTRAINT teammetrics_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS teammetrics_team_id_key
    ON public.teammetrics(team_id);


ALTER TABLE IF EXISTS public.teammicrosites
    ADD CONSTRAINT teammicrosites_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS teammicrosites_team_id_key
    ON public.teammicrosites(team_id);


ALTER TABLE IF EXISTS public.teamrevenuesharing
    ADD CONSTRAINT teamrevenuesharing_modified_by_fkey FOREIGN KEY (modified_by)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.teamrevenuesharing
    ADD CONSTRAINT teamrevenuesharing_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_team_revenue_sharing_team_id
    ON public.teamrevenuesharing(team_id);


ALTER TABLE IF EXISTS public.teamroleconfigurations
    ADD CONSTRAINT teamroleconfigurations_team_id_fkey FOREIGN KEY (team_id)
    REFERENCES public.teams (team_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.teams
    ADD CONSTRAINT teams_master_guide_id_fkey FOREIGN KEY (master_guide_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.user_roles
    ADD CONSTRAINT user_roles_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS public.useractivitylogs
    ADD CONSTRAINT useractivitylogs_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS idx_user_activity_logs_user_id
    ON public.useractivitylogs(user_id);


ALTER TABLE IF EXISTS public.userroles
    ADD CONSTRAINT userroles_user_id_fkey FOREIGN KEY (user_id)
    REFERENCES public.users (user_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;

END;



-- =============================================
-- TRIGGERS
-- =============================================

-- Social Media Triggers
CREATE OR REPLACE FUNCTION update_post_interaction_counts_incremental()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- Increment the appropriate counter
        IF NEW.interaction_type = 'like' THEN
            UPDATE public.micrositeposts
            SET likes_count = likes_count + 1,
                updated_at = CURRENT_TIMESTAMP
            WHERE post_id = NEW.post_id;
        ELSIF NEW.interaction_type = 'save' THEN
            UPDATE public.micrositeposts
            SET saves_count = saves_count + 1,
                updated_at = CURRENT_TIMESTAMP
            WHERE post_id = NEW.post_id;
        END IF;
    ELSIF TG_OP = 'DELETE' THEN
        -- Decrement the appropriate counter
        IF OLD.interaction_type = 'like' THEN
            UPDATE public.micrositeposts
            SET likes_count = GREATEST(0, likes_count - 1),
                updated_at = CURRENT_TIMESTAMP
            WHERE post_id = OLD.post_id;
        ELSIF OLD.interaction_type = 'save' THEN
            UPDATE public.micrositeposts
            SET saves_count = GREATEST(0, saves_count - 1),
                updated_at = CURRENT_TIMESTAMP
            WHERE post_id = OLD.post_id;
        END IF;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_post_interaction_change_incremental
AFTER INSERT OR DELETE ON public.postinteractions
FOR EACH ROW
EXECUTE FUNCTION update_post_interaction_counts_incremental();

-- Enforcement Actions Validation Trigger
CREATE OR REPLACE FUNCTION check_committee_enforcement_authority()
RETURNS TRIGGER AS $$
BEGIN
    -- Ensure committee_role_level is not null and within the valid range
    IF NEW.committee_role_level IS NULL OR NEW.committee_role_level NOT BETWEEN 1 AND 4 THEN
        RAISE EXCEPTION 'Invalid committee_role_level: must be between 1 and 4';
    END IF;

    -- Check if the committee member has appropriate authority based on action type
    IF NEW.action_type = 'permanent_ban' OR NEW.action_type = 'team_dissolution' THEN
        IF NEW.committee_role_level > 1 THEN -- Only outdooer CEO (level 1) can permanently ban or dissolve teams
            RAISE EXCEPTION 'Only the outdooer CEO has authority to % users or teams', 
                           CASE WHEN NEW.action_type = 'permanent_ban' THEN 'permanently ban' 
                                ELSE 'dissolve' END;
        END IF;
    ELSIF NEW.action_type = 'temporary_suspension' AND NEW.committee_role_level > 2 THEN 
        -- Only Committee Chief (level 2) or CEO can issue temporary suspensions
        RAISE EXCEPTION 'Only Committee Chiefs or higher can issue temporary suspensions';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_enforcement_action
BEFORE INSERT ON public.enforcementactions
FOR EACH ROW
EXECUTE FUNCTION check_committee_enforcement_authority();

-- Team Metrics Initialization Trigger
CREATE OR REPLACE FUNCTION initialize_team_metrics()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.teammetrics (
        team_id,
        current_reservation_count,
        reservation_limit,
        total_events_count,
        total_activities_count,
        total_expeditions_count,
        total_revenue,
        total_commission_paid,
        last_updated
    ) VALUES (
        NEW.team_id,
        0,
        100, -- Default 100 participant limit
        0,
        0,
        0,
        0,
        0,
        CURRENT_TIMESTAMP
    );
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_team_creation_metrics
AFTER INSERT ON public.teams
FOR EACH ROW
EXECUTE FUNCTION initialize_team_metrics();

-- Guide Metrics Update Triggers
CREATE OR REPLACE FUNCTION update_guide_metrics_on_event_update()
RETURNS TRIGGER AS $$
BEGIN
    -- Handle activity status updates
    IF TG_TABLE_NAME = 'activities' AND NEW.activity_status != OLD.activity_status THEN
        IF NEW.activity_status = 'completed' THEN
            -- Increment completed activities count
            UPDATE public.guidemetrics
            SET activities_completed = activities_completed + 1,
                total_activities_led = total_activities_led + 1,
                last_activity_date = CURRENT_TIMESTAMP,
                updated_at = CURRENT_TIMESTAMP
            WHERE guide_id = NEW.leader_id;
        ELSIF NEW.activity_status = 'canceled' AND OLD.activity_status != 'completed' THEN
            -- Increment canceled activities count
            UPDATE public.guidemetrics
            SET activities_canceled = activities_canceled + 1,
                updated_at = CURRENT_TIMESTAMP
            WHERE guide_id = NEW.leader_id;
        END IF;
    
    -- Handle expedition status updates
    ELSIF TG_TABLE_NAME = 'expeditions' AND NEW.expedition_status != OLD.expedition_status THEN
        IF NEW.expedition_status = 'completed' THEN
            -- Increment completed expeditions count
            UPDATE public.guidemetrics
            SET expeditions_completed = expeditions_completed + 1,
                total_expeditions_led = total_expeditions_led + 1, 
                last_activity_date = CURRENT_TIMESTAMP,
                updated_at = CURRENT_TIMESTAMP
            WHERE guide_id = NEW.leader_id;
        ELSIF NEW.expedition_status = 'canceled' AND OLD.expedition_status != 'completed' THEN
            -- Increment canceled expeditions count
            UPDATE public.guidemetrics
            SET expeditions_canceled = expeditions_canceled + 1,
                updated_at = CURRENT_TIMESTAMP
            WHERE guide_id = NEW.leader_id;
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_activity_update
AFTER UPDATE OF activity_status ON public.activities
FOR EACH ROW
EXECUTE FUNCTION update_guide_metrics_on_event_update();

CREATE TRIGGER after_expedition_update
AFTER UPDATE OF expedition_status ON public.expeditions
FOR EACH ROW
EXECUTE FUNCTION update_guide_metrics_on_event_update();

-- Guide Ratings Trigger
CREATE OR REPLACE FUNCTION update_guide_metrics_on_rating()
RETURNS TRIGGER AS $$
BEGIN
    -- Check if guide record exists in metrics
    IF NOT EXISTS (SELECT 1 FROM public.guidemetrics WHERE guide_id = NEW.guide_id) THEN
        -- Create a new metrics record for this guide
        INSERT INTO public.guidemetrics (guide_id, total_rating_sum, total_ratings_count)
        VALUES (NEW.guide_id, NEW.rating, 1);
    ELSE
        -- Update the existing metrics record
        UPDATE public.guidemetrics
        SET total_rating_sum = total_rating_sum + NEW.rating,
            total_ratings_count = total_ratings_count + 1,
            updated_at = CURRENT_TIMESTAMP
        WHERE guide_id = NEW.guide_id;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_guide_rating_insert
AFTER INSERT ON public.guideratings
FOR EACH ROW
EXECUTE FUNCTION update_guide_metrics_on_rating();

-- Financial Triggers
CREATE OR REPLACE FUNCTION calculate_guide_earnings()
RETURNS TRIGGER AS $$
DECLARE
    reservation_record RECORD;
    guide_id INTEGER;
    team_id INTEGER;
    commission_rate DECIMAL(5, 2);
    team_share_percentage DECIMAL(5, 2) := 0.20; -- Default 20% to team
    guide_role_level INTEGER;
    payment_amount DECIMAL(10, 2);
    commission_amount DECIMAL(10, 2);
    guide_amount DECIMAL(10, 2);
    team_amount DECIMAL(10, 2);
BEGIN
    -- Only process completed payments
    IF NEW.payment_status = 'completed' THEN
        -- Get reservation details
        SELECT r.* INTO reservation_record
        FROM public.reservations r
        WHERE r.reservation_id = NEW.reservation_id;
        
        -- Get guide and team information
        IF reservation_record.activity_id IS NOT NULL THEN
            SELECT a.leader_id, a.team_id INTO guide_id, team_id
            FROM public.activities a
            WHERE a.activity_id = reservation_record.activity_id;
        ELSE
            SELECT e.leader_id, e.team_id INTO guide_id, team_id
            FROM public.expeditions e
            WHERE e.expedition_id = reservation_record.expedition_id;
        END IF;
        
        -- Get guide's role level in the team
        SELECT role_level INTO guide_role_level
        FROM public.team_members
        WHERE user_id = guide_id AND team_id = team_id;
        
        -- Get commission rate (standard 10% unless negotiated)
        SELECT COALESCE(custom_commission_rate, 10.0) INTO commission_rate
        FROM public.teammetrics
        WHERE team_id = team_id;
        
        payment_amount := NEW.amount;
        commission_amount := (payment_amount * commission_rate / 100);
        
        -- Calculate guide earnings
        guide_amount := payment_amount - commission_amount;
        team_amount := guide_amount * team_share_percentage;
        guide_amount := guide_amount - team_amount;
        
        -- Create guide earnings record
        INSERT INTO public.guideearnings (
            guide_id, 
            team_id, 
            payment_id, 
            reservation_id,
            activity_id,
            expedition_id,
            amount,
            team_share_amount,
            commission_amount,
            earnings_status,
            created_at
        ) VALUES (
            guide_id,
            team_id,
            NEW.payment_id,
            NEW.reservation_id,
            reservation_record.activity_id,
            reservation_record.expedition_id,
            guide_amount,
            team_amount,
            commission_amount,
            'pending',
            CURRENT_TIMESTAMP
        );
        
        -- Update team metrics
        UPDATE public.teammetrics
        SET total_revenue = total_revenue + payment_amount,
            total_commission_paid = total_commission_paid + commission_amount,
            last_updated = CURRENT_TIMESTAMP
        WHERE team_id = team_id;
        
        -- Distribute team share among team members according to role levels
        PERFORM distribute_team_revenue(team_id, team_amount, NEW.payment_id, NEW.reservation_id, 
                                       reservation_record.activity_id, reservation_record.expedition_id);
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_payment_insert_update
AFTER INSERT OR UPDATE OF payment_status ON public.payments
FOR EACH ROW
EXECUTE FUNCTION calculate_guide_earnings();

-- Team Revenue Validation Trigger
CREATE OR REPLACE FUNCTION validate_team_revenue_percentage()
RETURNS TRIGGER AS $$
DECLARE
    total_percentage DECIMAL(5, 2);
BEGIN
    SELECT COALESCE(SUM(percentage), 0) INTO total_percentage
    FROM public.teamrevenuesharing
    WHERE team_id = NEW.team_id AND sharing_id != COALESCE(NEW.sharing_id, -1);

    IF total_percentage + NEW.percentage > 100.0 THEN
        RAISE EXCEPTION 'Total revenue sharing percentage for team % exceeds 100%%', NEW.team_id;
    END IF;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER validate_team_revenue_percentage_trigger
BEFORE INSERT OR UPDATE ON public.teamrevenuesharing
FOR EACH ROW
EXECUTE FUNCTION validate_team_revenue_percentage();

-- Team Revenue Sharing Initialization
CREATE OR REPLACE FUNCTION initialize_team_revenue_sharing()
RETURNS TRIGGER AS $$
BEGIN
    -- Set default revenue sharing percentages by role level
    INSERT INTO public.teamrevenuesharing (team_id, role_level, percentage, modified_by)
    VALUES 
        (NEW.team_id, 1, 50.0, NEW.master_guide_id), -- Master Guide gets 50% of team share
        (NEW.team_id, 2, 30.0, NEW.master_guide_id), -- Tactical Guide gets 30% of team share
        (NEW.team_id, 3, 15.0, NEW.master_guide_id), -- Technical Guide gets 15% of team share
        (NEW.team_id, 4, 5.0, NEW.master_guide_id);  -- Base Guide gets 5% of team share
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_team_creation_revenue_sharing
AFTER INSERT ON public.teams
FOR EACH ROW
EXECUTE FUNCTION initialize_team_revenue_sharing();

-- Earnings Summary Update Trigger
CREATE OR REPLACE FUNCTION update_earnings_summary()
RETURNS TRIGGER AS $$
DECLARE
    year_val INTEGER;
    month_val INTEGER;
    participant_count_val INTEGER;
BEGIN
    year_val := EXTRACT(YEAR FROM NEW.created_at);
    month_val := EXTRACT(MONTH FROM NEW.created_at);
    
    -- Get the participant count from reservation
    SELECT participant_count INTO participant_count_val
    FROM public.reservations 
    WHERE reservation_id = NEW.reservation_id;
    
    -- If no participants, default to 1
    IF participant_count_val IS NULL THEN
        participant_count_val := 1;
    END IF;
    
    -- Update guide summary
    INSERT INTO public.earningssummaries (
        guide_id,
        team_id,
        year,
        month,
        total_earnings,
        total_team_share,
        total_commission,
        activity_count,
        expedition_count,
        participant_count,
        created_at,
        updated_at
    ) VALUES (
        NEW.guide_id,
        NEW.team_id,
        year_val,
        month_val,
        NEW.amount,
        NEW.team_share_amount,
        NEW.commission_amount,
        CASE WHEN NEW.activity_id IS NOT NULL THEN 1 ELSE 0 END,
        CASE WHEN NEW.expedition_id IS NOT NULL THEN 1 ELSE 0 END,
        participant_count_val,
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP
    )
    ON CONFLICT (guide_id, team_id, year, month)
    DO UPDATE SET
        total_earnings = public.earningssummaries.total_earnings + NEW.amount,
        total_team_share = public.earningssummaries.total_team_share + NEW.team_share_amount,
        total_commission = public.earningssummaries.total_commission + NEW.commission_amount,
        activity_count = public.earningssummaries.activity_count + 
                        CASE WHEN NEW.activity_id IS NOT NULL THEN 1 ELSE 0 END,
        expedition_count = public.earningssummaries.expedition_count + 
                          CASE WHEN NEW.expedition_id IS NOT NULL THEN 1 ELSE 0 END,
        participant_count = public.earningssummaries.participant_count + participant_count_val,
        updated_at = CURRENT_TIMESTAMP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_guide_earnings_insert
AFTER INSERT ON public.guideearnings
FOR EACH ROW
EXECUTE FUNCTION update_earnings_summary();

-- Expedition Route Calculation Trigger
CREATE OR REPLACE FUNCTION calculate_expedition_route()
RETURNS TRIGGER AS $$
DECLARE
    lat_lng_array TEXT := '[]';
    total_dist DECIMAL(8, 2) := 0;
    total_time DECIMAL(6, 2) := 0;
    loc_record RECORD;
    prev_lat DECIMAL(10, 8);
    prev_lng DECIMAL(11, 8);
    curr_lat DECIMAL(10, 8);
    curr_lng DECIMAL(11, 8);
    dist_km DECIMAL(8, 2);
    activity_recs CURSOR FOR
        SELECT a.activity_id, l.latitude, l.longitude, l.location_name
        FROM public.expeditionactivities ea
        JOIN public.activities a ON ea.activity_id = a.activity_id
        JOIN public.locations l ON a.location_id = l.location_id
        WHERE ea.expedition_id = NEW.expedition_id
        ORDER BY ea.sequence_order;
BEGIN
    -- Initialize variables for route calculation
    OPEN activity_recs;
    FETCH activity_recs INTO loc_record;
    
    -- Set first location as previous point
    IF FOUND THEN
        prev_lat := loc_record.latitude;
        prev_lng := loc_record.longitude;
        
        -- Start building the JSON array of coordinates
        lat_lng_array := '[' || 
            jsonb_build_object(
                'lat', prev_lat,
                'lng', prev_lng,
                'location', loc_record.location_name,
                'activity_id', loc_record.activity_id
            )::text;
    END IF;
    
    -- Loop through remaining locations
    LOOP
        FETCH activity_recs INTO loc_record;
        EXIT WHEN NOT FOUND;
        
        curr_lat := loc_record.latitude;
        curr_lng := loc_record.longitude;
        
        -- Calculate distance using Haversine formula
        WITH haversine AS (
            SELECT 6371 * 2 * asin(
                sqrt(
                    sin(radians((curr_lat - prev_lat)/2))^2 + 
                    cos(radians(prev_lat)) * cos(radians(curr_lat)) * 
                    sin(radians((curr_lng - prev_lng)/2))^2
                )
            ) AS distance
        )
        SELECT distance INTO dist_km FROM haversine;
        
        -- Accumulate distance
        total_dist := total_dist + dist_km;
        
        -- Estimate travel time
        total_time := total_time + (dist_km / 5);
        
        -- Add this point to the array
        lat_lng_array := lat_lng_array || ', ' || 
            jsonb_build_object(
                'lat', curr_lat,
                'lng', curr_lng,
                'location', loc_record.location_name,
                'activity_id', loc_record.activity_id
            )::text;
        
        -- Set current point as previous for next iteration
        prev_lat := curr_lat;
        prev_lng := curr_lng;
    END LOOP;
    CLOSE activity_recs;
    
    -- Finalize the JSON array
    lat_lng_array := lat_lng_array || ']';
    
    -- Create or update the expedition route record
    IF EXISTS (SELECT 1 FROM public.expeditionroutes WHERE expedition_id = NEW.expedition_id) THEN
        UPDATE public.expeditionroutes
        SET 
            total_distance_km = total_dist,
            total_travel_time_hours = total_time,
            route_points = lat_lng_array,
            route_summary = 'Route through ' || (SELECT COUNT(*) FROM public.expeditionactivities WHERE expedition_id = NEW.expedition_id) || ' locations',
            last_calculated = CURRENT_TIMESTAMP,
            updated_at = CURRENT_TIMESTAMP
        WHERE expedition_id = NEW.expedition_id;
    ELSE
        INSERT INTO public.expeditionroutes (
            expedition_id,
            total_distance_km,
            total_travel_time_hours,
            route_points,
            route_summary,
            last_calculated
        ) VALUES (
            NEW.expedition_id,
            total_dist,
            total_time,
            lat_lng_array,
            'Route through ' || (SELECT COUNT(*) FROM public.expeditionactivities WHERE expedition_id = NEW.expedition_id) || ' locations',
            CURRENT_TIMESTAMP
        );
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_expedition_activity_insert_update
AFTER INSERT OR UPDATE ON public.expeditionactivities
FOR EACH ROW
EXECUTE FUNCTION calculate_expedition_route();

-- Team Dissolution Trigger
CREATE OR REPLACE FUNCTION dissolve_team_on_master_guide_leave()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.role_level = 1 THEN -- If a Master Guide is leaving
        UPDATE public.teams
        SET team_status = 'dissolved',
            updated_at = CURRENT_TIMESTAMP
        WHERE team_id = OLD.team_id;
        
        -- Set all team members' records to reflect the team dissolution
        DELETE FROM public.team_members
        WHERE team_id = OLD.team_id;
        
        -- Log this significant event
        INSERT INTO public.auditlogs (user_id, action_type, entity_type, entity_id, description)
        VALUES (OLD.user_id, 'dissolve', 'team', OLD.team_id, 'Team dissolved due to Master Guide departure');
    END IF;
    RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_team_member_delete
AFTER DELETE ON public.team_members
FOR EACH ROW
EXECUTE FUNCTION dissolve_team_on_master_guide_leave();

-- Reservation Metrics Update Trigger
CREATE OR REPLACE FUNCTION update_team_metrics_after_reservation()
RETURNS TRIGGER AS $$
DECLARE
    team_id_var INTEGER;
    current_count INTEGER;
    team_limit INTEGER;
BEGIN
    -- Determine which team is affected
    IF NEW.activity_id IS NOT NULL THEN
        SELECT a.team_id INTO team_id_var
        FROM public.activities a
        WHERE a.activity_id = NEW.activity_id;
    ELSIF NEW.expedition_id IS NOT NULL THEN
        SELECT e.team_id INTO team_id_var
        FROM public.expeditions e
        WHERE e.expedition_id = NEW.expedition_id;
    END IF;
    
    -- Get current reservation count and limit
    SELECT current_reservation_count, reservation_limit 
    INTO current_count, team_limit
    FROM public.teammetrics
    WHERE team_id = team_id_var;
    
    -- Check if this reservation would exceed the team's limit
    IF current_count + NEW.participant_count > team_limit THEN
        RAISE EXCEPTION 'This reservation would exceed the team''s limit of % participants', team_limit;
    END IF;
    
    -- Update the metrics
    UPDATE public.teammetrics
    SET current_reservation_count = current_reservation_count + NEW.participant_count,
        last_updated = CURRENT_TIMESTAMP
    WHERE team_id = team_id_var;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_reservation_insert
BEFORE INSERT ON public.reservations
FOR EACH ROW
EXECUTE FUNCTION update_team_metrics_after_reservation();

-- Master Guide Activity Monitoring Trigger
CREATE OR REPLACE FUNCTION monitor_master_guide_activity()
RETURNS TRIGGER AS $$
BEGIN
    -- Update the master guide activity monitor
    IF NEW.role_type = 'guide' THEN
        -- Check if this user is a Master Guide
        IF EXISTS (SELECT 1 FROM public.team_members WHERE user_id = NEW.user_id AND role_level = 1) THEN
            -- Update last login timestamp
            UPDATE public.master_guide_activity_monitor
            SET last_login = CURRENT_TIMESTAMP,
                updated_at = CURRENT_TIMESTAMP
            WHERE master_guide_id = NEW.user_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER after_user_login
AFTER UPDATE OF last_login ON public.users
FOR EACH ROW
EXECUTE FUNCTION monitor_master_guide_activity();

-- Utility Functions
CREATE OR REPLACE FUNCTION log_user_activity(
    p_user_id INTEGER,
    p_activity_type VARCHAR(50),
    p_ip_address VARCHAR(45),
    p_user_agent TEXT,
    p_device_info TEXT DEFAULT NULL,
    p_location_data TEXT DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
    INSERT INTO public.useractivitylogs (
        user_id,
        activity_type,
        ip_address,
        user_agent,
        device_info,
        location_data
    ) VALUES (
        p_user_id,
        p_activity_type,
        p_ip_address,
        p_user_agent,
        p_device_info,
        p_location_data
    );
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION create_audit_log(
    p_user_id INTEGER,
    p_action_type VARCHAR(50),
    p_entity_type VARCHAR(50),
    p_entity_id INTEGER,
    p_description TEXT,
    p_ip_address VARCHAR(45) DEFAULT NULL,
    p_user_agent TEXT DEFAULT NULL
)
RETURNS VOID AS $
BEGIN
    INSERT INTO public.auditlogs (
        user_id,
        action_type,
        entity_type,
        entity_id,
        description,
        ip_address,
        user_agent
    ) VALUES (
        p_user_id,
        p_action_type,
        p_entity_type,
        p_entity_id,
        p_description,
        p_ip_address,
        p_user_agent
    );
END;
$ LANGUAGE plpgsql;

-- Team Revenue Distribution Function
CREATE OR REPLACE FUNCTION distribute_team_revenue(
    p_team_id INTEGER,
    p_team_amount DECIMAL(10, 2),
    p_payment_id INTEGER,
    p_reservation_id INTEGER,
    p_activity_id INTEGER,
    p_expedition_id INTEGER
)
RETURNS VOID AS $
DECLARE
    team_member_rec RECORD;
    total_percentage DECIMAL(5, 2) := 0;
    member_percentage DECIMAL(5, 2);
    member_amount DECIMAL(10, 2);
BEGIN
    -- Get total percentage to validate configuration
    SELECT SUM(percentage) INTO total_percentage
    FROM public.teamrevenuesharing
    WHERE team_id = p_team_id;
    
    -- Check if percentages add up to 100%
    IF total_percentage <> 100.0 THEN
        RAISE EXCEPTION 'Team revenue sharing percentages do not add up to 100%% for team %', p_team_id;
    END IF;
    
    -- Distribute to each team member by role
    FOR team_member_rec IN (
        SELECT tm.user_id, tm.role_level, trs.percentage
        FROM public.team_members tm
        JOIN public.teamrevenuesharing trs ON tm.team_id = trs.team_id AND tm.role_level = trs.role_level
        WHERE tm.team_id = p_team_id
    )
    LOOP
        -- Calculate this member's portion
        member_percentage := team_member_rec.percentage;
        member_amount := (p_team_amount * member_percentage / 100);
        
        -- Create earnings record for this team member
        IF member_amount > 0 THEN
            INSERT INTO public.guideearnings (
                guide_id,
                team_id,
                payment_id,
                reservation_id,
                activity_id,
                expedition_id,
                amount,
                team_share_amount,
                commission_amount,
                earnings_status,
                created_at
            ) VALUES (
                team_member_rec.user_id,
                p_team_id,
                p_payment_id,
                p_reservation_id,
                p_activity_id,
                p_expedition_id,
                member_amount,
                0, -- No further team sharing
                0, -- Commission already taken
                'pending',
                CURRENT_TIMESTAMP
            );
        END IF;
    END LOOP;
END;
$ LANGUAGE plpgsql;


